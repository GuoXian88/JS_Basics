
/*细细的滚动条*/
&::-webkit-scrollbar {
    width: 3px;
}
&::-webkit-scrollbar-thumb {
    background-color: #b4b4b4;
    border-radius: 4px;
}
&::-webkit-scrollbar-button {
    display: none;
}
&::-webkit-scrollbar-track {
    background-color: #f4f4f4;
}

/*A > B will only select B that are direct children to A (that is, there are no other elements inbetween).

A B will select any B that are inside A, even if there are other elements between them.

display: inline-block可以不换行

1.CSS 三大概念: 浮动 定位 盒模型
元素加背景，背景会应用于content + padding
outline绘制在border之上不会影响页面布局
width 和 height是指contend的宽高
padding不能为负, margin可以为负
box-sizing: border-box会把border也计算在内
普通文档流中的div的margin会叠加（外和内都会）, 取最大的
空元素的margin会和自身叠加
但是行内框inline,浮动框或position: absolute框之间不会叠加

定位：普通流，浮动，绝对定位
修改行内元素尺寸的唯一方法是修改line-height或者水平border, padding , margin,还有就是将
属性设置为display: inline-block

position: relative元素还占据原来的空间,相对自己在文档流中的位置偏移进行定位,会覆盖其他的div

position: absolute元素位置与文档流无关，不占据空间。其他元素的布局相当于
绝对定位元素不存在一样
绝对定位元素的位置相对于离它最近已经定位的祖先来定位，层叠可用z-index来控制显示
position:fixed是绝对定位的一种,相对于viewport定位,而不是父级元素
fixed  不使用 top left right 之类的定位的时候
margin又是根据父级来定位的
蒙层这种也可以把div放到body的子级



float的div移动直到碰到了包含它的div或者是另外一个float的div边缘
float脱离文档流
float不影响页面元素,但是inline元素会被浮云元素影响(压缩)
清除浮动是让元素的某个方向没有浮云元素

overflow: hidden或者auto会清除浮动

居中
div {
  background:red;
  position:absolute;
  color:#fff;
  top:50%;
  left:50%;
  padding:15px;
  -ms-transform: translateX(-50%) translateY(-50%);
  -webkit-transform: translate(-50%,-50%);
  transform: translate(-50%,-50%);
}
padding
flex
text-align:center, margin: auto
display:table-cell, text-align: center, vertical-align: middle

媒体查询
@media (max-width: 600px) {
  .facet_sidebar {
    display: none;
  }
}

@media screen and (device-aspect-ratio: 16/9), screen and (device-aspect-ratio: 16/10) { ... }

<link rel="stylesheet" media="screen and (max-device-width: 799px)" />

css选择器尽量specific
Conversely, not used just as a quick crutch to override the styling of something instead of figuring out how the CSS was structured and working by the original author.
an ID has infinitely more specificity value! That is, no amount of classes alone can outweigh an ID.
If the element has inline styling, that automatically1 wins (1,0,0,0 points)
For each ID value, apply 0,1,0,0 points
For each class value (or pseudo-class or attribute selector), apply 0,0,1,0 points
For each element reference, apply 0,0,0,1 point

z-index:
z-index only effects elements that have a position value other than static (the default).
Without any z-index value, elements stack in the order that they appear in the DOM (the lowest one down at the same hierarchy level appears on top). 
Also note that nesting plays a big role. If an element B sits on top of element A, a child element of element A can never be higher than element B.


事实上在一个层叠上下文中一共可以有7种层叠等级，列举如下：

背景和边框 —— 形成层叠上下文的元素的背景和边框。 层叠上下文中的最低等级。
负z-index值 —— 层叠上下文内有着负z-index值的子元素。
块级盒 —— 文档流中非行内非定位子元素。
浮动盒 —— 非定位浮动元素。
行内盒 —— 文档流中行内级别非定位子元素。
z-index: 0 —— 定位元素。 这些元素形成了新的层叠上下文。
正z-index值 —— 定位元素。 层叠上下文中的最高等级。


html语义化

a. 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；

b. 用户体验：例如title、alt用于解释名词或解释图片信息的标签尽量填写有含义的词语、label标签的活用；

c. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；

d. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以有意义的方式来渲染网页；

e. 便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。


遵循html标签原本的含义，让机器也能读懂(爬虫或者搜索引擎SEO)
CSS命名规范（id和class的命名）无论是 ID 还是 class，对任何东西最好总是根据它是什么而不是它看上去是什么样子来命名

*/

.clear:after {
    content: '.';
    height: 0;
    visibility: hidden;
    display:block;
    clear: both
}